## 목차

- [15장. let, const 키워드와 블록 레벨 스코프](#15장-let-const-키워드와-블록-레벨-스코프)

---

# 15장 let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점

### 15.1.1 변수 중복 선언 허용

초기화문이 없는 변수 선언문은 무시되고, 에러는 발생하지 않음.

### 15.1.2 함수 레벨 스코프

var 키워드로 선언한 변수-> 함수의 코드 블록만을 지역 스코프로 인정.  
함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수.

## 15.2 let 키워드

### 15.2.2 블록 레벨 스코프

let 키워드로 선언한 변수는 모든 코드 블록(함수, if, for, while, try/catch 문 등)을 지역 스코프로 인정하는 `블록 레벨 스코프`를 따름.

### 15.2.3 변수 호이스팅

let 키워드로 선언한 변수를 변수 선언문 이전에 참조하면 참조 에러 발생.  
let으로 선언한 변수는 **선언 단계**와 **초기화 단계**가 분리되어 진행.  
스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간 -> `일시적 사각시대(TDZ, Temporal Dead Zone)`

```js
console.log(foo); // -> ReferenceError: foo is not defined

let foo;
console.log(foo); // undefined

foo = 1;
console.log(foo); // 1
```

따라서 변수 호이스팅이 일어나지 않는 것처럼 보이지만 그렇지 않음.

자바스크립트는 모든 선언을 호이스팅함.  
단, ES6에서 도입된 let, const, class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작.

## 15.3 const 키워드

### 15.3.1 선언과 초기화

const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 함.

```js
const foo; // SyntaxError: Missing initializer in const declaration
```

### 15.3.3 상수

상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야 함.  
일반적으로 상수 이름은 대문자로 선언, 스네이크 케이스로 표현.

### 15.3.4 const 키워드와 객체

const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있음.  
const 키워드는 **재할당을 금지할 뿐 "불변"을 의미하지 않음**. -> 객체를 변경하는 것은 가능.  
객체가 변경되더라도 변수에 할당된 참조 값은 변경되지 않음.
