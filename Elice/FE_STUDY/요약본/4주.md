## 목차

- [동등/일치 비교 연산자](#동등/일치-비교-연산자)
- [이벤트 루프](#이벤트-루프)
- [콜스택과 힙](#콜스택과-힙)
- [this의 바인딩](#this의-바인딩)
- [호이스팅(Hoisting)](#호이스팅Hoisting)
- [var vs let vs const](#var-vs-let-vs-const)

---

# 동등/일치 비교 연산자

좌항과 우항의 피연산자가 같은 값으로 평가되는지를 비교해 불리언 값(true/false)을 반환한다.

동등 비교 연산자는 느슨하고, 일치 비교 연산자는 엄격하다.

- \== : 동등 비교 : x==y : x와 y의 값이 같음
- \=== : 일치 비교 : x==y : x와 y의 값이 같고 타입도 같음
- != : 부동등 비교 : x !=y : x와 y의 값이 다름
- !== : 불일치 비교 : x !==y : x와 y의 값과 타입이 다름

**부동등 비교 연산자와 불일치 비교 연산자는 각각 동등 비교 연산자와 일치 비교 연산자의 반대 개념이라 이해하면 된다.**

둘 다 동일한 비교를 하지만,
엄격한(Strict) 동등 비교 연산자(===)의 경우, **타입변환(Type conversion)이 일어나지 않으며 타입이 일치**해야 한다.

## 동등 비교 연산자

**동등 비교 연산자**는 좌항과 우항의 피연산자를 비교할 때,  
먼저 암묵적 타입 변환을 통해 타입을 일치 시킨 후 같은 값인지 비교한다.

좌항과 우항의 피연산자가 타입이 다르더라도 '암묵적 타입 변환'후에 같은 값일 수 있다면 true를 반환한다.
단, 객체/배열의 경우는 객체(참조) 타입(변경 가능한 값)이기 때문에 두 연산자 모두 동일하게 동작한다.
문자열의 경우, 자바스크립트에서 문자열은 원시타입이지만 객체로도 만들 수 있기 때문에 그 동등 비교가 다르다.

**안전한 타입 체크와 더 좋은 코드를 위해 엄격한 일치 비교 연산자(===)를 사용하는 것이 바람직하다.**

## 일치 비교 연산자

**일치 비교 연산자**는 좌황과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환하여,  
암묵적 타입 변환을 하지 않기에 예측하기 쉽다.

일치 비교 연산자에서 주의할 것은 NaN이다.
NaN은 자신과 일치 하지 않는 유일한 값이기에, 숫자가 NaN인지 조사하려면 빌트인 함수 Number.isNaN 을 사용해야 한다.
그 외에도 숫자 0도 주의해야 한다. 자바 스크립트에는 +0과 -0이 있는데 이들을 비교하면 모두 true를 반환한다.

---

# 이벤트 루프

`들어가기 전에`

자바스크립트는 단일 스레드(Single-threaded) 기반 언어로, 자바스크립트 엔진이 단일 콜 스택을 갖는다. 이 말은 요청이 동기적으로 처리된다는 것을 의미한다. 그렇다면 비동기 요청은 어떻게 처리될 수 있을까? 그것은 바로 자바스크립트를 실행하는 환경인 브라우저나 Node.js가 담당한다. 여기서 자바스크립트 엔진과 그 실행 환경을 상호 연동시켜주는 장치가 바로 이벤트 루프이다. 따라서, 이벤트 루프는 자바스크립트 엔진에 있지 않고 그 환경에 속한다.

`이벤트 루프란?`

이벤트(event)를 처리하는 반복되는 동작(loop)이다. 즉, Node.js가 비동기-이벤트 동작을 처리하는 일련의 반복 동작이다. 이벤트 루프를 이해하면 비동기 코딩이 어떤 순서로 수행되는지에 대해 이해할 수 있다.

`이벤트 루프 구성요소`

<li>콜 스택(Call Stack) : 작성된 함수들이 등록되는 LIFO 스택으로, 이벤트 루프는 콜 스택이 비어있을 때까지 스택의 함수를 실행</li>
<li>메시지 큐(Message Queue) : setTimeout 같은 지연실행 함수를 등록하는 FIFO 큐로, 정해진 timing이 끝나고 콜 스택이 비어있을 경우, 등록된 함수를 콜 스택에 추가</li>
<li>잡 큐(Job Queue) : Promise에 등록된 콜백을 등록하는 FIFO 큐로, 상위 함수가 종료되기 전에 콜 스택이 비어있지 않더라도 잡 큐에 등록된 콜백을 콜스택에 추가</li>

---

# 콜스택과 힙

## 메모리 힙(Memory Heap)

- 객체, 배열, 함수 등 크기가 동적으로 변할 수 있는 참조타입 값을 저장
- 쉽게 말하면, Memory Heap이라는 창고 속에 겉에 이름이 라벨지로 붙어 있는 참조 타입 값의 박스가 있는 것
- 갑자기 데이터가 커질 수도 있는, 배열과 객체처럼 정렬되지 않은 데이터들을 저장할 수 있음
- 변수, 함수 저장, 호출 등의 작업이 발생

## 콜 스택(Call Stack)

1. 원시타입 값 저장
2. 함수 호출의 실행 컨텍스트(Execution Context)를 저장

- 코드 실행에 따라 하나씩 스택이 쌓임 (LIFO)
- 그런 뒤 Memory Heap에서 작업 수행에 필요한 것들을 찾아 작업 수행

---

# this의 바인딩

자바스크립트에서 함수가 호출될 때는
기존 매개변수로 전달되는 인자 값에 대해서
arguments 객체와 this 인자가 함수 내부로 암묵적으로 전달된다.

일반적인 프로그래밍 언어에서의 this는 인스턴스 자신(self)을 가리키는 참조변수이다.

하지만 자바스크립트의 경우 Java, C++ 등과 같이 this에 바인딩되는 객체가 한가지가 아니고,
해당 함수 호출 방식에 따라 this에 바인딩되는 객체가 결정된다.

따라서,
함수 실행 컨텍스트에서 this는 함수가 어떻게 호출됐는지에 집중해서 파악하면 된다.

#함수 호출 방식과 this 바인딩

자바스크립트의 경우 함수 호출 방식에 의해 this에 바인딩할 어떤 객체가 동적으로 결정된다.
기본적으로 다음 4가지 경우가 있다.

## 1. 일반 함수 호출시 this

일반 함수 실행 방식에서 this는 글로벌 객체다.

```js
// 일반 함수 실행 방식
function foo() {
  console.log(this); // 'this' === global 객체 (브라우저상에선 window 객체)
}

foo();
```

## 2. 메소드 호출(혹은 Dot Notation)시 this

객체의 메소드를 호출할 때는 해당 메소드를 호출한 객체로 바인딩된다.

```js
var age = 100;

var Ray = {
  age: 20,
  foo: function foo() {
    console.log(this.age); // 'console.log(Ray.age)'와 같다. 결과값: 20
  },
};

Ray.foo(); //function foo를 실행
```

메소드 방식이므로, ' . ' 앞에 있는 객체, 즉, Ray라는 객체가 this로 설정된다.
Ray.foo()의 결과값은 20이 나온다.

## 3. 명시적 바인딩(Explict Binding) - call, apply, bind

```js
var age = 100;

function foo(a, b, c, d, e) {
  console.log(this.age);
  console.log(arguments);
}

var Ray = {
  age: 20,
};

foo.call(Ray, 1, 2, 3, 4, 5);
// 첫번째 인자(Ray)가 this 값으로 설정된다. 결과값: 20
// 나머지 인자는 각각 a, b, c, d, e로 넘어간다. 결과값: 유사 배열 [1, 2, 3, 4, 5]
// call은 인자의 수가 정해져 있지 않다.

foo.apply(Ray, [1, 2, 3, 4, 5]);
// 첫번째 인자(Ray)가 this 값으로 설정된다.
// 결과값은 call과 같다.
// apply는 인자를 2개만 받기 때문에, 여러 인자를 넣으려면 배열로 묶어줘야 한다.
```

## 4. new 키워드

new 키워드를 사용하면,
빈 객체가 생성되고,
해당 함수의 this 값에 할당된다.

```js
function foo () {
    //new 사용시: 1. this = {} 빈 객체 생성

    this.name = 'Dessert';

    //2. Dessert를 담아줌.
    //{
    //    name: 'Dessert'
    //}

    //3. return this;
    //new 키워드를 사용하면, return을 사용하지 않더라도,
    자동적으로 this에 담긴 객체가 반환된다고 생각하면 된다.

}

var ApplePie = new foo();

conosle.log(ApplePie);
```

---

# 호이스팅(Hoisting)

- 호이스팅이란 '끌어올린다'는 뜻으로 변수 및 함수 선언문이 스코프 내의 최상단으로 끌어 올려지는 현상.

- `var` 키워드로 선언한 변수의 경우 `undefined` 값으로 변수 초기화.
- `let`, `const`로 선언한 변수도 호이스팅의 대상이지만 var과 달리 변수를 초기화하지 않기 때문에 변수 초기화 전에 값을 참조하는 코드가 나오면 ReferenceError 발생.

### 함수 호이스팅

- **함수 선언문은 호이스팅되지만 함수 표현식은 호이스팅되지 않음.**
- 함수 표현식의 경우 변수에 호이스팅이 발생해 ReferenceError가 발생하진 않지만 그 값이 undefined이기 때문에 함수 호출 시 TypeError 발생.

- 동일한 이름의 변수 선언문과 함수 선언문이 있을 경우 함수 선언문이 우선.

---

# var vs let vs const

- 변수 : 데이터가 저장된 메모리 상의 주소를 기억해서 메모리에 저장된 값을 참조
- 자바스크립트는 동적 타입 언어 : 타입 지정 없이 값이 할당되는 과정에서 값의 타입에 의해서 자동으로 타입이 결정됨.

## var

1. 함수레벨 스코프
2. var 키워드 생략 허용
3. 변수 중복 선언 허용
4. 변수를 선언하기 전에 참조 가능

## let

1. 블록레벨 스코프
2. 변수 중복 선언 금지
3. 일시적 사각지대 – 변수를 선언하기 전에 참조 불가능

## const

1. 블록레벨 스코프
2. 선언과 동시에 재할당
3. 객체는 const로 선언하기
