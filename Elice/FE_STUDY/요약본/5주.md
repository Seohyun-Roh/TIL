## 목차

- [IIFE(즉시 호출 함수 표현식)](#IIFE즉시-호출-함수-표현식)
- [Module System(모듈 시스템)](#Module-System모듈-시스템)
- [프로토타입](#프로토타입)
- [엄격 모드](#엄격-모드)
- [new의 동작방식](#new의-동작방식)
- [ES6 - Let과 Const, 화살표 함수](#ES6--Let과-Const-화살표-함수)

---

# IIFE(즉시 호출 함수 표현식)

주로 이름 충돌 최소화 및 private 변수 생성에 사용되는 자바스크립트 디자인 패턴
함수 표현식으로서 익명 또는 기명 함수를 만들고는, 그 즉시 함수 호출을 함

```js
(function () {
  console.log('IIFE');
})();
```

언제 사용하나요?

1. 이름충돌 최소화
   즉시 실행한 뒤에 전역에서 사라지기 때문에 전역 scope와 충돌하지 않기 때문에 불필요한 전역변수나 함수 생성을 줄인다

2. closure와 private 데이터
   IIFE안에 closure를 사용해서 전역변수의 억제는 물론 캡슐화까지 구현할 수 있다.

3. 변수의 별칭
   라이브러리에 동일한 이름의 전역변수가 있을 때, 라이브러리끼리 묶어줌으로써 충돌을 방지해준다.

4. 자주 사용되는 특정한 키워드를 압축
   스크립트가 길어질수록 파일의 용량을 크게 줄일 수 있다.

---

# Module System(모듈 시스템)

### 여러가지 기능들에 관한 코드가 모여 있는 하나의 파일 (코드를 분리하기 위한 방법)

이전에 웹에서 사용되던 JS는 module 개념 없이 한 파일에 모두 작성됨
하지만 서버 사이드에서 사용한다면 이는 생산성 면에서 문제가 될 것이므로
모듈화가 필요했고, 그 기준을 통일하기 위해 여러 모듈 시스템이 등장

## 장점

- 유지보수성
- 네임스페이스화
- 재사용성

## Common JS (Common JavaScript)

- module.exports
- 서버 사이드에서 사용
- 서버 사이드 자바스크립트 런타임인 node.js의 독자적인 방식
- 첫 require 시에만 실행하고 cache 되므로 여러 번 실행할 모듈은 함수형으로 작성해야 함
- 의존성 패키지, 모듈, json 파일 사용 가능
- 동기적 작동

## AMD (Asynchronous Module Definition)

- define 함수 -클라이언트 사이드에서 주로 사용 (서버도 OK)
- 비동기적 작동
- webpack 같은 모듈 번들러를 통한 모듈 번들링 필요

## UMD (Universal Module Definition)

- Common JS와 AMD를 합친 모듈 시스템
- 두 가지 모두 사용 가능 -> Common JS/AMD 두 가지 모듈을 만들 필요가 없음
  - 서로 호환되지 않는 문제 해결하기 위함
- 여러 모듈 로더에서 사용 가능
- 엄밀히 말하면 디자인 패턴에 가까움

## ESM (ECMAScript Module)

- export & import
- 모든 브라우저가 지원하는 것은 아님
- Babel의 @babel/plugin-transform-modules-commonjs를 통해 변환시켜서 사용
- ES6부터 언어 자체에 모듈을 탑재해 편리해짐, 공식 표준으로 제공
  - 앞서 보았던 것처럼 시스템을 위한 코드가 별도로 필요하다면 매우 번거로움

---

# 프로토타입

`프로토타입이란?`

JavaScript에서는 기본 데이터 타입을 제외한 모든 것이 객체이다. 객체가 만들어지기 위해서는 자신을 만드는 데 사용된 원형인 프로토타입 객체를 이용하여 객체를 만들어야 한다. 이때 만들어진 객체 안에 **proto** (비표준) 속성이 자신을 만들어낸 원형을 의미하는 프로토타입 객체를 참조하는 숨겨진 링크가 있다. 이 숨겨진 링크를 프로토타입이라고 정의한다

`프로토타입 객체란?`

함수를 정의하면 다른 곳에 생성되는 프로토타입 객체는 자신이 다른 객체의 원형이 되는 객체이다. 모든 객체는 프로토타입 객체에 접근할 수 있다. 프로토타입 객체도 동적으로 런타임에 멤버를 추가할 수 있다. 같은 원형을 복사해서 생성된 모든 객체는 추가된 멤버를 사용할 수 있다.

`코드의 재사용`

<li>기본 방법 : 부모에 해당하는 함수를 이용하여 객체를 생성. 자식에 해당하는 함수의 prototype 속성이 부모 함수를 이용하여 생성한 객체를 참조하도록 하는 방법</li>
<li>생성자 빌려쓰기 : 기본 방법의 문제점인 자식 함수에서 받은 인자를 부모 함수로 인자를 전달하지 못했던 부분을 해결. 부모 함수의 this에 자식 객체를 바인딩하는 방식</li>
<li>생성자 빌려 쓰고 프로토타입 지정해주기 : 방법 1과 방법 2 문제점들을 보완하면서 Java에서 예상할 수 있는 동작 방식과 유사</li>
<li>프로토타입 공유 : 부모 생성자를 한 번도 호출하지 않으면서 프로토타입 객체를 공유하는 방법</li>
<li>prototypal한 방식의 재사용 : Object.create()를 사용하여 객체를 생성과 동시에 프로토타입 객체를 지정하는 방법</li>

---

# 엄격 모드

ECMAScript 5에서 처음으로 소개된 strict 모드는 자바스크립트 코드에 더욱 엄격한 오류 검사를 적용해 준다.

## 엄격 모드 적용하기

### 전체 스크립트에 Strict mode 적용

```js
'use strict'; // 전체 스크립트를 strict 모드로 설정함.

try {
  num = 3.14; // 선언되지 않은 변수를 사용했기 때문에 오류를 발생시킴.
} catch (ex) {
  document.getElementById('text').innerHTML = ex.name + '<br>';

  document.getElementById('text').innerHTML += ex.message;
}
```

### 일부 함수에 Strict mode 적용

```js
str = '실수!'; // 선언되지 않은 변수를 사용했지만 자동으로 전역 변수로 선언됨.

document.getElementById('noStrict').innerHTML = str + '<br>';

function StrictBlock() {
  'use strict'; // 함수 블록만을 strict 모드로 설정함.

  try {
    num = 123; // 선언되지 않은 변수를 사용했기 때문에 오류를 발생시킴.
  } catch (ex) {
    document.getElementById('funcStrict').innerHTML = ex.name + '<br>';

    document.getElementById('funcStrict').innerHTML += ex.message;
  }
}

StrictBlock();
```

---

# new의 동작방식

new는 자바스크립트에서 **생성자(constructor)로서 객체를 만드는 역할을 하는 함수**다.

new constructor는 new로 인해 비어있는 객체를 만들고 반환하기 때문에 "객체의 생성자"의 역할을 하게된다.

즉, 함수에 new를 붙이면 그 return 값은 객체가 된다.

new 연산자의 동작 방식은 다음과 같다.

1. 빈 객체를 생성한다.
2. [[prototype]]의 속성을 생성자 호출할 함수의 prototype 속성으로 지정한다.
3. 객체를 생성하고 이 객체를 this 로 지정한다.
4. 함수를 호출하고 해당 함수의 this 로 위에서 지정한 객체를 사용한다.
5. 함수의 리턴값이 원시값이라면 새로 만들어진 객체가 리턴되고 리턴값이 객체라면 해당 객체가 리턴된다.

- 생성자는 "객체에 대한 초기화"작업을 수행하며, 이를 활용해 코드의 재사용성을 높일 수 있다!
- 생성자 함수는 일반함수와 구분하기 위해서 첫글자를 대문자로 표시한다.

---

# ES6 - Let과 Const, 화살표 함수

## Const & Let

let은 변수 선언에 사용하고 const는 상수를 위해 사용한다.  
이는 블록 레벨 스코프를 따르기 때문에 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.

또한 let, const 키워드로는 동일한 이름을 갖는 변수를 중복해서 선언할 수 없고 선언 단계와 초기화 단계가 분리되어 진행되기 때문에 초기화 전에 변수에 접근하려고 하면 참조 에러가 발생한다.

## 화살표 함수

전통적인 함수 표현의 간편한 대안으로, `=>`로 사용할 수 있다.

```js
// 매개변수 지정 방법
    () => { ... }
     x => { ... }
(x, y) => { ... }

// 함수 몸체 지정 방법
x => { return x * x }
x => x * x
```

화살표 함수는 익명 함수로만 사용할 수 있기 때문에 호출을 위해서는 함수 표현식을 사용한다.

일반 함수와 화살표 함수의 가장 큰 차이점은 this이다.  
일반 함수에서는 함수 호출 방식에 의해 this에 바인딩할 객체가 동적으로 결정된다.  
하지만 화살표 함수의 this는 함수를 선언할 때 바인딩할 객체가 결정된다. 화살표 함수의 this는 언제나 상위 스코프의 this를 가리키고, 이를 Lexical this라고 한다.  
또한 call, apply, bind 메소드를 사용해서 this를 변경할 수 없다.
