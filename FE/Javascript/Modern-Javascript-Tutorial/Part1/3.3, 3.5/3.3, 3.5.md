## 3.3 주석

**리팩토링 팁: 함수 분리하기**

함수 내 코드 일부를 새로운 함수로 옮기는 것이 유익할 때도 많음.

함수 이름 자체가 주석 역할을 하므로 코드를 쉽게 이해할 수 있게 됨 -> 자기 설명적인(self-descriptive) 코드

**리팩토링 팁: 함수 만들기**

함수는 주석이 없어도 그 존재 자체가 무슨 역할을 하는지 설명할 수 있어야 함.

하지만 실무에선 '설명이 담긴' 주석을 작성하는 게 불가피한 경우도 있음.  
알고리즘이 복잡한 코드를 작성하는 경우나 최적화를 위해 코드를 약간 비틀어 작성할 땐 설명을 적어주어야 함.  
이런 경우를 제외하곤 간결하고 코드 자체만으로 설명이 가능하게 코딩해야 함.

### 좋은 주석

**아키텍처를 설명하는 주석**

---

## 3.5 테스트 자동화와 Mocha

### 테스트는 왜 해야 하는가?

개발 중에 콘솔 창 등을 이용해 실제 실행 결과가 기대했던 결과가 같은지 계속 비교하면서 원하는 기능이 잘 구현되고 있는지 확인. 하지만 이렇게 수동으로 코드를 '재실행'하는 것은 상당히 불완전함. -> 무언가를 놓치기 쉬움.

모든 유스케이스를 상기하면서 코드를 수정하는 것은 거의 불가능함.

### BDD(Behavior Driven Development)

BDD -> 테스트(test), 문서(documentation), 예시(example)을 한데 모아놓은 개념.

실제 개발 사례를 통해 BDD에 대해 알아보자.

### 거듭제곱 함수와 명세서

x를 n번 곱해주는 함수 `pow(x, n)`을 구현하고 있다고 가정.

본격적으로 코드를 작성하기 전, 코드가 무슨 일을 하는지 상상한 후 이를 자연어로 표현해야 함.  
이 때 만들어진 산출물을 BDD에서 명세서(specification) 또는 스펙(spec)이라고 함.  
명세서에는 유스케이스에 대한 자세한 설명과 테스트가 담겨있음.

```js
describe("pow", function () {
  it("주어진 숫자의 n 제곱", function () {
    assert.equal(pow(2, 3), 8);
  });
});
```

스펙은 세 가지 주요 구성 요소로 이루어짐.

- `describe("title", function() { ... })`: 구현하고자 하는 기능에 대한 설명. `it` 블록을 한데 모아주는 역할도 함.
- `it("유스 케이스 설명", function() { ... })`: `it`의 첫 번째 인수에는 특정 유스케이스에 대한 설명. 누구나 읽을 수 있고 이해할 수 있는 자연어로 적음. 두 번째 인수엔 유스 케이스 테스트 함수가 들어감.
- `assert.equal(value1, value2)`: 기능을 제대로 구현했다면 it 블록 내의 코드 assert.equal(value1, value2)이 에러 없이 실행됨.

명세서는 실행 가능. 실행하면 `it` 블록 안의 테스트가 실행됨.

### 개발 순서

1. 명세서 초안 작성. 초안엔 기본적인 테스트도 들어감.
2. 명세서 초안을 보고 코드 작성.
3. 코드가 작동하는지 확인하기 위해 Mocha라 불리는 테스트 프레임워크를 사용해 명세서 실행. 코드가 잘못 작성되었다면 에러 출력. 에러가 더 출력되지 않을 때까지 코드 수정.
4. 모든 테스트를 통과하는 코드 초안 완성.
5. 명세서에 지금까지 고려하지 않았던 유스케이스 몇 가지 추가. 테스트가 실패하기 시작.
6. 세 번째 단계로 돌아가 테스트를 모두 통과할 때까지 코드 수정.
7. 기능 완성까지 3~6단계 반복.

### 스펙 실행하기

```js
describe("pow", function () {
  it("주어진 숫자의 n 제곱", function () {
    assert.equal(pow(2, 3), 8);
    assert.equal(pow(3, 4), 81);
  });
});
```

```js
describe("pow", function () {
  it("2를 세 번 곱하면 8입니다.", function () {
    assert.equal(pow(2, 3), 8);
  });

  it("3을 네 번 곱하면 81입니다.", function () {
    assert.equal(pow(3, 4), 81);
  });
});
```

assert에서 에러 발생 시 it 블록은 즉시 종료됨. 따라서 기존 it 블록에 assert를 하나 더 추가하면 첫 번째 assert가 실패했을 때 두 번째 assert의 결과를 알 수 없음.  
두 번째 방법처럼 it 블록을 하나 더 추가해 테스트를 분리해서 작성하면 더 많은 정보를 얻을 수 있음(추천!).

따라서 테스트를 추가할 땐 **테스트 하나에서 한 가지만 확인하기** 규칙을 따르는 게 좋음.

> #### **`before/after`와 `beforeEach/afterEach`**
>
> 함수 `before`는 (전체)테스트가 실행되기 전에 실행, 함수 `after`는 (전체)테스트가 실행된 후에 실행.  
> 함수 `beforeEach`는 매 `it`이 실행되기 전에 실행, 함수 `afterEach`는 매 `it`이 실행된 후에 실행.

### 스펙 확장하기

함수 `pow`도 n이 조건에 맞지 않으면 NaN을 반환해야 함. 이를 검사하는 테스트 추가.

```js
describe("pow", function () {
  // ...

  it("n이 음수일 때 결과는 NaN입니다.", function () {
    assert.isNaN(pow(2, -1));
  });

  it("n이 정수가 아닐 때 결과는 NaN입니다.", function () {
    assert.isNaN(pow(2, 1.5));
  });
});
```

기존에는 n이 음수이거나 정수가 아닌 경우를 생각하지 않고 구현했기 때문에, 새롭게 추가한 테스트는 실패할 수 밖에 없음.  
BDD의 핵심은 여기에 있음. 실패할 수밖에 없는 테스트를 추가하고, 테스트를 통과할 수 있게 코드를 개선하는 것.

> **다양한 assertion**  
> `assert.equal(value1, value2)` – value1과 value2의 동등성을 확인(value1 == value2).  
> `assert.strictEqual(value1, value2)` – value1과 value2의 일치성을 확인(value1 === value2).  
> `assert.notEqual, assert.notStrictEqual` – 비 동등성, 비 일치성을 확인.  
> `assert.isTrue(value)` – value가 true인지 확인(value === true).  
> `assert.isFalse(value)` – value가 false인지 확인(value === false).  
> 이 외의 assertion은 [docs](https://www.chaijs.com/api/assert/)에서 확인 가능.

### 요약

스펙이 있기 때문에 개발자는 안전하게 함수를 개선하거나 변경 가능.

코드가 바뀌어도 기존에 구현된 기능에 영향을 주지 않게 하는 건 대규모 프로젝트에서 매우 중요함. 프로젝트 규모가 커지면 함수 하나를 이곳저곳에서 사용하는데, 수동으로 변경된 함수가 이 함수를 사용하는 모든 곳에서 제대로 동작하는지 확인하는 건 불가능하기 때문.

**잘 테스트 된 코드는 더 나은 아키텍처를 만든다.**
