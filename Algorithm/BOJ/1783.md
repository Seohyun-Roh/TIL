# BOJ 1783번: 병든 나이트

## 문제

병든 나이트가 N × M 크기 체스판의 가장 왼쪽아래 칸에 위치해 있다. 병든 나이트는 건강한 보통 체스의 나이트와 다르게 4가지로만 움직일 수 있다.

1. 2칸 위로, 1칸 오른쪽
2. 1칸 위로, 2칸 오른쪽
3. 1칸 아래로, 2칸 오른쪽
4. 2칸 아래로, 1칸 오른쪽

병든 나이트는 여행을 시작하려고 하고, 여행을 하면서 방문한 칸의 수를 최대로 하려고 한다. 병든 나이트의 이동 횟수가 4번보다 적지 않다면, 이동 방법을 모두 한 번씩 사용해야 한다. 이동 횟수가 4번보다 적은 경우(방문한 칸이 5개 미만)에는 이동 방법에 대한 제약이 없다.

체스판의 크기가 주어졌을 때, 병든 나이트가 여행에서 방문할 수 있는 칸의 최대 개수를 구해보자.

## 입력

첫째 줄에 체스판의 세로 길이 N와 가로 길이 M이 주어진다. N과 M은 2,000,000,000보다 작거나 같은 자연수이다.

## 출력

병든 나이트가 여행에서 방문할 수 있는 칸의 개수중 최댓값을 출력한다.

## 예제 입력 1

    100 50

## 예제 출력 1

    48

## My Solution

```python
n, m = map(int, input().split())  # n: 세로길이, m: 가로길이

if n == 1 or m == 1:
    print(1)
elif n == 2:
    print(min(4, (m + 1) // 2))
elif m <= 6:
    print(min(4, m))
else:
    print(m - 2)
```

### Result & Review

시간: 72 ms
코드 길이: 205 B

- 복잡한 구현 문제라고 생각하고 체스판부터 그리고 있었는데 간단하게 생각하면 되는 문제였다.

- n(세로 길이)이나 m(가로 길이)이 1일 경우는 움직이지 못하므로 1을 출력해주면 된다.

- n이 2일 경우에는 2, 3번 방법밖에 쓰지 못하므로 최대로 갈 수 있는 칸의 갯수는 4개이다. (4번 이상 움직이려면 1~4번 방법을 모두 사용해야 하므로.) n이 2일 때 m이 2라면 결과는 1, 3이라면 2, 4라면 2, 5라면 3이다. 따라서 (m + 1)//2과 4를 비교해 작은 값을 출력해주면 된다.

- 세로 길이가 3이상인 경우, 가로 길이가 6이하이면 1~4까지 모든 방법을 쓸 수 없다. 그럴 때는 1번, 4번 방법을 쓰는 것이 최선이다. 1, 4번 방법만 이용해 갈 수 있는 최대 칸은 4이고, m의 길이가 그보다 작을 경우에는 m이 최대이다. 따라서 둘을 비교해 최소값을 구해주면 된다.

- 그 외 경우에는 최대 경우가 m-2이다. (2, 3번 방법 1번씩 이용. 나머지는 1, 4번 방법으로 해주면 최대 경우가 된다.)
